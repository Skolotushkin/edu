# Глава 7: Шестнадцатеричный, восьмеричный, ASCII, UTF-8, Юникод, Руны

## Шестнадцатеричный, восьмеричный, ASCII, UTF-8, Юникод, Руны

### 1. Что вы узнаете из этой главы?
- Что такое Unicode, ASCII и UTF-8?
- Как хранятся символы.
- Что такое тип руны?

### 2. Рассмотренные технические концепции
- ASCII
- UTF-8
- Шестнадцатеричный
- Восьмеричный
- Руна
- Кодовая точка

### 3. Введение
В предыдущей главе мы рассмотрели десятичную и двоичную систему счисления. В этой главе речь пойдет о шестнадцатеричном и восьмеричном числе. Также мы поговорим о ASCII и UTF-8.

× Бумажное и цифровое издание этой книги доступны [здесь](#).
Я также снял видеокурс по созданию реального проекта с помощью Go.

### 4. Основание 16: шестнадцатеричное представление
Чтобы представить двоичное число, необходимо выровнять множество нулей и единиц. Эта нотация является многословной. Чтобы представить десятичное число 1324, нам нужно было использовать 11 символов в двоичной системе. Вот почему нам нужна система нумерации, более удобная для выражения больших чисел.

Шестнадцатеричный код также является позиционной системой счисления, в которой используется 16 символов для обозначения числа.

Приставка "Hexa" в переводе с латыни означает 6.

Десятичная дробь происходит от латинского слова "Decem", что означает 10.

Эти символы представляют собой цифры и буквы. Мы используем цифры от 0 до 9 (10 символов) и буквы от A до F (6 символов).

Возьмем пример: 1324 по десятичному основанию эквивалентно 52C по основанию 16.

Эквивалентность между шестнадцатеричными и десятичными знаками:

- Цифры от 0 до 9 соответствуют одному и тому же значению в десятичной системе.
- Буквы A соответствуют 10, буква B — 11... и так далее.

Это специфика шестнадцатеричной системы счисления; мы используем буквы для обозначения числовых значений.

Шестнадцатеричное представление:

Вы можете видеть, что мы ввели в эту нотацию буквы. Это потому, что от 0 до 9 у вас есть десять символов, десять цифр, но при системе нумерации с основанием 16 нам нужно еще шесть символов. Вот почему мы взяли первые шесть букв алфавита. Это исторический выбор; другие символы могли бы заменить буквы, система была бы все той же.

Метод, который вы можете использовать для преобразования шестнадцатеричного числа в десятичное число, аналогичен предыдущему. Берем крайний правый символ, находим его десятичный эквивалент, затем умножаем его на 16 в степени 0. В нашем примере у нас есть буква C. Эквивалент C равен 12.

Чтобы напечатать шестнадцатеричное представление числа, можно использовать функции `fmt`:

```go
package main

import "fmt"

func main() {
    n := 2548
    fmt.Printf("%x", n)
}
```

Эта программа выведет: `9f4` (что является шестнадцатеричным представлением десятичного числа 2548). `%x` — это глагол форматирования для шестнадцатеричного формата (со строчными буквами).

Обратите внимание, что `n` — это число, обозначаемое с помощью десятичной системы.

Вы также можете использовать `%X` для вывода шестнадцатеричного числа с заглавными буквами:

```go
package main

import "fmt"

func main() {
    n := 2548
    fmt.Printf("%X", n)
}
```

Выход: `9F4`.

Если вы хотите представить число в шестнадцатеричном формате в своем коде, добавьте `0x` перед числом:

```go
package main

import "fmt"

func main() {
    n := 2548
    n2 := 0x9F4
    fmt.Printf("%X\n", n)
    fmt.Printf("%x\n", n2)
}
```

Выход:

```
9F4
9f4
```

Чтобы вывести число с основанием десять, можно использовать глагол `%d`:

```go
package main

import "fmt"

func main() {
    n2 := 0x9F4
    fmt.Printf("Decimal: %d\n", n2)
}
```

Выход:

```
Decimal: 2548
```

### 5. Основание 8: восьмеричное представление
Я чуть не забыл еще одну систему счисления! Восьмеричный!

В нем используется основание 8, что означает восемь разных символов. Были выбраны цифры от 0 до 7. Преобразование из десятичной в восьмеричную аналогично методам, которые я представил ранее. Рассмотрим пример:

Восьмеричное представление:

Мы начинаем с крайнего правого символа и умножаем его на восемь в степени 0, что равно 1. Затем берем следующий символ: 5 умножаем его на восемь в степени 1, что равно 8...

Восьмеричная система используется, в частности, для представления прав доступа к файлу для операционных систем Unix.

Так же, как и шестнадцатеричный, пакет `fmt` определяет два глагола форматирования для восьмеричного числа:

```go
package main

import "fmt"

func main() {
    n2 := 0x9F4
    fmt.Printf("Decimal: %d\n", n2)

    // n3 is represented using the octal numeral system
    n3 := 02454
    // alternative: n3 := 0o2454

    // convert in decimal
    fmt.Printf("decimal: %d\n", n3)

    // n4 is represented using the decimal numeral system
    n4 := 1324
    // output n4 (decimal) in octal
    fmt.Printf("octal: %o\n", n4)
    // output n4 (decimal) in octal (with a 0o prefix)
    fmt.Printf("octal with prefix: %O\n", n4)
}
```

Выход:

```
Decimal: 2548
decimal: 1324
octal: 2454
octal with prefix: 0o2454
```

`%o` позволяет вывести число в восьмеричной системе.

`%O` позволяет вывести число в восьмеричной системе с префиксом `0o`.

### 6. Биты представления данных, полубайты, байты и слова
Бит — это аббревиатура от Binary digit. Например, `1010010110` состоит из 11 двоичных цифр, другими словами, 11 бит. Очень часто биты группируются вместе. Группы существуют в различных размерах:

- Ниббл состоит из 4 бит.
- Байт состоит из 8 бит (двух полубайтов).
- Слово состоит из 16 бит (двух байтов).
- Двойное слово состоит из 32 бит (двух слов).
- Четырехугольник состоит из \(16 \times 4 = 64\) бит (четыре слова).

С помощью Go вы можете создать срез байтов. Многие распространенные стандартные функции и методы пакета принимают в качестве аргументов срезы байтов. Давайте посмотрим, как мы можем создать срез байта.

```go
package main

import "fmt"

func main() {
    b := make([]byte, 0)
    b = append(b, 255)
    b = append(b, 10)
    fmt.Println(b)
}
```

В предыдущем сниппете мы создали срез байтов (с помощью встроенной функции `make`), а затем добавили к срезу два числа.

Тип байта Go является псевдонимом `uint8`. `uint8` означает, что мы можем хранить беззнаковые (без каких-либо знаков, то есть без отрицательных чисел) целые числа на 8 битах (байте) данных. Минимальное значение равно 0 (двоичная цифра `00000000`), максимальное значение равно 255 (`11111111`, что эквивалентно десятичному числу \(2^7 + 2^6 + 2^5 + 2^4 + 2^3 + 2^2 + 2^1 + 2^0\)).

Вот почему мы можем добавить к байтовому срезу только числа от 0 до 255. Если вы попытаетесь добавить число больше 255, вы получите следующую ошибку:

```
constant 256 overflows byte
```

Чтобы напечатать двоичное представление числа, вы можете использовать глагол форматирования `%b`:

```go
package main

import "fmt"

func main() {
    n2 := 0x9F4
    fmt.Printf("Decimal: %d\n", n2)
    fmt.Printf("Binary: %b\n", n2)
}
```

Выход:

```
Decimal: 2548
Binary: 100111110100
```

### 7. А как насчет других символов?
Что делать, если вы хотите хранить что-то еще, кроме цифр? Например, как мы могли бы хранить это хайку от Масаоки Шики:

```
spring rain:
browsing under an umbrella
at the picture-book store
```

Подходит ли тип байта? Байт — это не что иное, как целое число без знака, хранящееся на 8 битах. Это хайку состоит из букв и специальных символов. У нас есть `:` и `-`, у нас также есть переносы строк... Как мы можем хранить эти символы?

Мы должны найти способ дать каждой букве и даже специальным символам уникальный код. Возможно, вы слышали про UTF-8, ASCII, Unicode? В этом разделе будет объяснено, что это такое и как они работают. Когда я начал программировать (этого не было в Go), кодировка символов была чем-то непонятным, и мне это было неинтересно. Я думаю, что кодировка символов может быть необходима, потому что я проводил ночи на работе над проблемами, которые можно было бы решить с базовым пониманием кодировки символов.

История кодирования символов очень богата. С развитием телеграфа нам понадобился способ кодирования сообщений таким образом, чтобы их можно было транспортировать по электрическому проводу. Одной из самых ранних попыток была азбука Морзе. Он состоит из четырех символов: короткий сигнал, длинный сигнал, короткий пробел, длинный пробел (Википедия). Каждая буква алфавита может быть закодирована в азбуке Морзе. Например, A был закодирован как короткий сигнал, за которым последовал длинный сигнал. Знак плюс `+` был закодирован как `короткий, длинный, длинный, короткий`.

× Бумажное и цифровое издание этой книги доступны [здесь](#).
Я также снял видеокурс по созданию реального проекта с помощью Go.

### 8. Лексика
Нам нужно определить общий словарь, чтобы понять кодировку символов:

- **Символ**: это может быть написано нашей рукой. Это несет в себе значение. Например, знак `+` — это символ. Это значит добавить что-то к чему-то другому. Символом может быть буква, знак или идеограмма.
- **Набор символов**: это набор различных символов. Часто вы увидите или услышите аббревиатуру `кодировка`.
- **Кодовая точка**: каждый символ из набора символов имеет эквивалентное числовое значение, которое однозначно идентифицирует этот символ. Это числовое значение является кодовой точкой.

### 9. Наборы символов и кодировка
Есть один набор символов, который вы хотите знать: Юникод. Это стандарт, в котором перечислено подавляющее большинство символов из живых языков, которые сегодня используются на компьютерах.

Он состоит из 137 374 символов для версии 11.0. Юникод похож на огромную таблицу, которая сопоставляет символ с кодовой точкой. Например, символ `A` сопоставляется с кодовой точкой `U+0041`.

С Unicode у нас есть основа, наша таблица символов, теперь следующая задача — найти способ закодировать эти символы, поместить эти кодовые точки в байты данных. Именно этим и занимаются ASCII и UTF-8.

### 10. Как работает ASCII?
ASCII означает American Standard Code for Information Interchange. Он был разработан в шестидесятых годах. Цель состояла в том, чтобы найти способ кодирования символов, используемых для передачи сообщений.

ASCII кодирует символы на семи двоичных цифрах. Еще одна двоичная цифра — бит четности. Бит четности используется для обнаружения ошибок передачи. Он добавляется после семи первых битов, и его значение равно 0. Если количество единиц нечетное, то бит четности равен 1; если число четное, ему присваивается значение 0.

Байт данных может хранить каждый символ (8 бит). Сколько целых чисел вы можете создать, имея всего 7 битов? С помощью одного бита мы можем закодировать два значения, 0 и 1, с помощью 2 битов мы можем закодировать четыре различных значения. Когда вы добавляете бит, вы умножаете на два количество значений, которые вы можете закодировать. С помощью 7 бит можно закодировать 128 целых чисел. В более общем случае, количество целых чисел без знака, которые вы можете закодировать с n двоичными цифрами, равно двум в степени n.

Количество двоичных цифр и возможных значений в кодировке:

| Количество бит | Количество значений |
|----------------|---------------------|
| 1              | 2                   |
| 2              | 4                   |
| 3              | 8                   |
| 4              | 16                  |
| 5              | 32                  |
| 6              | 64                  |
| 7              | 128                 |

ASCII позволяет кодировать 128 различных символов. Для каждого символа у нас есть определенная кодовая точка. Целочисленные значения без знака представляют собой кодовые точки.

Кодовая таблица USASCII:

На предыдущем рисунке вы можете увидеть таблицу кодов USASCII. Эта таблица позволяет преобразовать байт в символ. Например, буква B эквивалентна `1000010` (двоичная) (столбец 4, строка 2).

### 11. Как работает UTF-8?
UTF-8 означает Universal Character Set Transformation Format — 8 бит. Он был придуман двумя людьми, которые также являются создателями Go: Робом Пайком и Кеном Томпсоном! Конструкция этого типа кодирования очень гениальна. Попробую пояснить это кратко:

UTF-8 — это система кодирования с переменной шириной. Это означает, что символы кодируются с помощью от одного до четырех байтов (байт представляет собой восемь двоичных цифр).

Система кодирования переменной ширины UTF-8:

На рисунке вы можете увидеть правила кодирования UTF-8. Символ может быть закодирован в диапазоне от 1 до 4 байт.

Кодовые точки, которые могут быть закодированы с помощью только одного байта, находятся в диапазоне от U+0000 до U+007F (включительно). Этот диапазон состоит из 128 символов.

Но нужно закодировать больше символов! Именно поэтому у создателей UTF-8 возникла идея добавить байты в систему. Первый дополнительный байт начинается с единицы и 0; они фиксированные. Он сигнализирует декодерам, что теперь мы используем 2 байта для кодирования наших символов, мы просто добавляем биты `110`. Он говорит декодерам UTF-8: `Будьте осторожны; нас 2!`.

Если мы используем 2 байта, у нас есть 11 свободных битов (8 * 2 - 5 (фиксированные биты) = 11). Мы можем закодировать символы, которые имеют кодовую точку Юникода от U+0080 до U+07FF. Сколько символов это представляет?

- `0080` в шестнадцатеричном формате = 128 в десятичной дроби.
- `07FF` в шестнадцатеричном формате = 2047 в десятичной дроби.
- С `0080` по `07FF` есть 2047 - 128 + 1 = 1920.

Вы можете спросить, почему мы добавляем единицу к подсчету... Это связано с тем, что символы индексируются от кодовой точки 0.

Если вы используете 3 байта, то первый байт будет начинаться с фиксированных битов `1110`. Это будет сигнализировать декодерам о том, что символ закодирован с использованием 3 байт. Другими словами, следующие символы будут начинаться после третьего байта. Два дополнительных байта начинаются с `10`. С тремя байтами кодирования у вас есть 16 свободных битов (8 * 3 - 8 (фиксированные биты) = 16). Вы можете кодировать символы от U+0800 до U+FFFF.

Если вы поняли, как это работает для 3 байт, то у вас не должно возникнуть проблем с тем, чтобы узнать, как система работает с 4 байтами. Внутри нашего первого байта мы фиксируем пять первых битов (`11110`). Затем у нас есть три дополнительных байта. Если мы вычтем фиксированные биты из общего числа битов, то получим 21 бит. Это означает, что мы можем кодировать кодовые точки от U+10000 до U+10FFFF.

× Бумажное и цифровое издание этой книги доступны [здесь](#).
Я также снял видеокурс по созданию реального проекта с помощью Go.

### 12. Строки
Строка — это `последовательность символов`. Например, `Test` — это строка, состоящая из 4 различных символов: T, e, s и t. Преобладают строки; мы используем их для хранения необработанного текста внутри нашей программы. Как правило, они читаются человеком. Например, имя и фамилия пользователя приложения — это две строки.

Символы могут быть из разных наборов символов. Если вы используете набор символов ASCII, вам придется выбирать из 128 доступных символов.

Каждый символ имеет соответствующую кодовую точку в наборе символов. Как мы уже видели ранее, кодовая точка — это произвольно выбранное целое число без знака. Строки хранятся с помощью байтов. Возьмем пример строки, состоящей только из символов ASCII:

```
Hello
```

Каждый символ может храниться в одном байте. Эта строка может быть сохранена со следующими битами:

```
01001000 01100101 01101100 01101100 01101111
```

Двоичный эквивалент строки `Hello` (ASCII).

В Go строки являются неизменяемыми, что означает, что они не могут быть изменены после создания.

### 13. Строковые литералы
Существует два `типа` строковых литералов:

- **Необработанные строковые литералы**. Они определяются между обратными кавычками.
- **Интерпретируемые строковые литералы**. Они определяются между двойными кавычками.

К запрещенным символам относятся:

- Обратные кавычки.
- Отброшенные символы.
- Возврат каретки (`\r`).
- Новые линии.
- Неэкранированные двойные кавычки.

```go
package main

import "fmt"

func main() {
    raw := `spring rain:
browsing under an umbrella
at the picture-book store`
    fmt.Println(raw)

    interpreted := "i love spring"
    fmt.Println(interpreted)
}
```

Вы можете заметить, что внутри этого фрагмента кода мы не сказали Go, какой набор символов мы используем. Это связано с тем, что строковые литералы неявно кодируются с использованием UTF-8.

### 14. Руны
За кулисами строка — это набор байтов. Мы можем перебирать байты строки с помощью цикла `for`:

```go
package main

import "fmt"

func main() {
    s := "Я люблю Golang"
    for i := 0; i < len(s); i++ {
        fmt.Printf("%x ", s[i])
    }
}
```

Выход:

```
d0 9f d0 bf d0 bb d1 8e d0 bd d0 b8 20 6c 75 62 6c 75 20 47 6f 6c 61 6e 67
```

Сообщение на предыдущем рисунке означает `Я люблю Golang`, два первых иероглифа китайские.

Эта программа будет перебирать каждый символ строки. Внутри петли `for` `v` имеет тип `rune`. Руна — это встроенный тип, который определяется следующим образом:

```go
type rune = int32
```

Руна представляет собой кодовую точку Юникода.

Кодовые точки Юникода являются числовыми значениями.

По соглашению они всегда обозначаются в следующем формате: `U+X`, где `X` — шестнадцатеричное представление кодовой точки. `X` должен состоять из четырех символов.

Если `X` содержит меньше четырех символов, мы добавляем нули.

Пример: Символ `o` имеет кодовую точку, равную 111 (в десятичной дроби). 111 в шестнадцатеричном формате записывается как `6F`. Десятичная кодовая точка — `U+006F`.

Чтобы вывести кодовую точку в обычном формате, можно использовать глагол формата `%U`:

```go
package main

import "fmt"

func main() {
    var aRune rune = 'Z'
    fmt.Printf("Unicode Code point of &#39;%c&#39;: %U\n", aRune, aRune)
}
```

Обратите внимание, что вы можете создать руну с помощью простых кавычек:

```go
package main

import "fmt"

func main() {
    var aRune rune = 'Z'
    fmt.Printf("Unicode Code point of &#39;%c&#39;: %U\n", aRune, aRune)
}
```

### 15. Проверьте себя
#### 15.1 Вопросы
- Верно или неверно: `785G` — это шестнадцатеричная цифра.
- Верно или неверно: `785F` и `785F` представляют одну и ту же величину.
- Какой глагол форматирования представляет шестнадцатеричное число (с заглавной буквой)?
- Какой глагол форматирования представляет число в десятичной дроби?
- Что такое кодовая точка?
- Заполните пробелы. `_______` — это набор символов, `_______` — это стандарт кодировки.
- Верно или неверно: UTF-8 позволяет кодировать меньше символов, чем ASCII.
- Сколько байт можно использовать для кодирования символа с помощью системы кодирования UTF-8?

#### 15.2 Ответы
- Верно или неверно: `785G` — это шестнадцатеричная цифра.

  Ложный.

  Буква `G` не может быть частью шестнадцатеричных чисел.

  Однако буквы от `A` до `F` могут быть частью шестнадцатеричного числа.

- Верно или неверно: `785F` и `785F` представляют одну и ту же величину.

  Это действительно так.

  Тот факт, что буква написана с заглавной буквы, не меняет ее значения.

- Какой глагол форматирования представляет шестнадцатеричное число (с заглавной буквой)?

  `%X`

- Какой глагол форматирования представляет число в десятичной дроби?

  `%d`

- Что такое кодовая точка?

  Кодовая точка — это числовое значение, которое идентифицирует символ в наборе символов.

- Заполните пробелы. `_______` — это набор символов, `_______` — это стандарт кодировки.

  Unicode — это набор символов, UTF-8 — стандарт кодировки.

- Верно или неверно: UTF-8 позволяет кодировать меньше символов, чем ASCII.

  Ложный.

- Сколько байт можно использовать для кодирования символа с помощью системы кодирования UTF-8?

  От 1 до 4 байт.

  Это зависит от символа.

× Бумажное и цифровое издание этой книги доступны [здесь](#).
Я также снял видеокурс по созданию реального проекта с помощью Go.

### 16. Ключевых выводов
- Шестнадцатеричная система счисления — это такая же система счисления, как десятичная и двоичная.
- В шестнадцатеричном формате число представляется с помощью 16 символов: `0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F`.
- С помощью функций `fmt` (`fmt.Sprintf` и `fmt.Printf`) вы можете использовать `глаголы форматирования` для представления числа с помощью определенной системы счисления:
  - `%b` для двоичных файлов.
  - `%X` и `%x` для шестнадцатеричного.
  - `%d` для десятичной дроби.
  - `%o` для восьмеричного.
- **Символ**: это может быть написано нашей рукой, что передает значение. Пример: `-`, `A`, `a`.
- **Набор символов**: это набор различных символов. Часто вы увидите или услышите аббревиатуру `кодировка`.
- **Кодовая точка**: каждый символ из набора символов имеет эквивалентное числовое значение, которое однозначно идентифицирует этот символ. Это числовое значение является кодовой точкой.
- **Юникод** — это набор символов, состоящий из 137 000 + символов.
- Каждый символ имеет кодовую точку. Например, символ `A` эквивалентен кодовой точке `U+0041`.
- **ASCII** — это метод кодирования, который может кодировать только 128 символов.
- **UTF-8** — это метод кодирования, который может кодировать более 1 миллиона символов.
- В кодировке UTF-8 любой символ кодируется с использованием от 1 до 4 байт.
- **Руна** является встроенным типом.
- Руна представляет собой кодовую точку символа в Юникоде.
- Для создания руны можно использовать простые кавычки:

```go
var aRune rune = 'Z'
```

- Когда вы перебираете строку, вы будете перебирать руны:

```go
package main

import "fmt"

func main() {
    b := "hello"
    for i := 0; i < len(b); i++ {
        fmt.Println(b[i])
    }
    // will output:
    // 104
    // 101
    // 108
    // 108
    // 111
    // and NOT:
    // h
    // e
    // l
    // l
    // o
}
```

- В Go строки являются неизменяемыми, что означает, что они не могут быть изменены после создания.
